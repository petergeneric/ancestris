/*
 * ReleveCompletionPanel.java
 *
 * Created on 9 déc. 2012, 11:57:25
 */

package ancestris.modules.releve;

import ancestris.core.pluginservice.AncestrisPlugin;
import ancestris.modules.releve.editor.EditorBeanField;
import ancestris.modules.releve.editor.EditorBeanGroup;
import ancestris.modules.releve.model.DataManager.RecordType;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;
import java.util.HashMap;
import java.util.Iterator;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;

/**
 * permet de decocher les noms ou prenom que l'on ne souhaite pas voir
 * apparaitre dans les listes de completion
 * @author Michel
 */
public class ReleveEditorConfigDialog extends javax.swing.JFrame {

    static private Color greyColor = new Color(240, 240, 240);

    
    /**
     * affiche la fenetre de completion des noms
     */
    static public void  showEditorConfigPanel() {
        ReleveEditorConfigDialog configPanel = new ReleveEditorConfigDialog();
        configPanel.initData();
    }

    /** Creates new form ReleveCompletionPanel */
    public ReleveEditorConfigDialog() {
        initComponents();

        // je configure la position de la fenetre
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screen.width - getWidth())/ 2, (screen.height -getHeight()) / 2, getWidth(), getHeight());

        setTitle(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveOptionsPanel.jButtonConfigEditor.text"));

        jTableBirth = new ConfigTable();
        jTableBirth.setUpdateSelectionOnSort(false);
        jTableBirth.setSelectionBackground(getBackground());
        jTableBirth.setAutoCreateRowSorter(false);
        MergeTableRenderer mergeTableRendererBirth = new MergeTableRenderer();
        jTableBirth.setDefaultRenderer(Object.class, mergeTableRendererBirth);
        jScrollPaneBirth.setViewportView(jTableBirth);

        jTableMarriage = new ConfigTable();
        jTableMarriage.setUpdateSelectionOnSort(false);
        jTableMarriage.setSelectionBackground(getBackground());
        jTableMarriage.setAutoCreateRowSorter(false);
        MergeTableRenderer mergeTableRendererMarriage = new MergeTableRenderer();
        jTableMarriage.setDefaultRenderer(Object.class, mergeTableRendererMarriage);
        jScrollPaneMarriage.setViewportView(jTableMarriage);

        jTableDeath = new ConfigTable();
        jTableDeath.setUpdateSelectionOnSort(false);
        jTableDeath.setSelectionBackground(getBackground());
        jTableDeath.setAutoCreateRowSorter(false);
        MergeTableRenderer mergeTableRendererDeath = new MergeTableRenderer();
        jTableDeath.setDefaultRenderer(Object.class, mergeTableRendererDeath);
        jScrollPaneDeath.setViewportView(jTableDeath);

        jTableMisc = new ConfigTable();
        jTableMisc.setUpdateSelectionOnSort(false);
        jTableMisc.setSelectionBackground(getBackground());
        jTableMisc.setAutoCreateRowSorter(false);
        MergeTableRenderer mergeTableRendererMisc = new MergeTableRenderer();
        jTableMisc.setDefaultRenderer(Object.class, mergeTableRendererMisc);
        jScrollPaneMisc.setViewportView(jTableMisc);

        pack();
    }

    private void initData() {
        jTableBirth.setModel(new ConfigModel(RecordType.birth));
        jTableMarriage.setModel(new ConfigModel(RecordType.marriage));
        jTableDeath.setModel(new ConfigModel(RecordType.death));
        jTableMisc.setModel(new ConfigModel(RecordType.misc));
        setVisible(true);
    }

    private void saveConfig() {
         EditorBeanGroup.savePreferences();

        // je notifie les instance de la mise a jour
        for (ReleveTopComponent tc : AncestrisPlugin.lookupAll(ReleveTopComponent.class)) {
            tc.udpdateEditorVisibleField();
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jPanelConfig = new javax.swing.JPanel();
        jTabbedPane = new javax.swing.JTabbedPane();
        jScrollPaneBirth = new javax.swing.JScrollPane();
        jTableBirth = new javax.swing.JTable();
        jScrollPaneMarriage = new javax.swing.JScrollPane();
        jTableMarriage = new javax.swing.JTable();
        jScrollPaneDeath = new javax.swing.JScrollPane();
        jTableDeath = new javax.swing.JTable();
        jScrollPaneMisc = new javax.swing.JScrollPane();
        jTableMisc = new javax.swing.JTable();
        jPanelFirstName = new javax.swing.JPanel();
        jButtonOk = new javax.swing.JButton();
        jButtonCancel = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        jPanelConfig.setPreferredSize(new java.awt.Dimension(300, 400));
        jPanelConfig.setLayout(new java.awt.GridBagLayout());

        jTableBirth.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        jTableBirth.setUpdateSelectionOnSort(false);
        jScrollPaneBirth.setViewportView(jTableBirth);

        jTabbedPane.addTab(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveTopComponent.panelBirth.TabConstraints.tabTitle"), new javax.swing.ImageIcon(getClass().getResource("/ancestris/modules/releve/images/Birth.png")), jScrollPaneBirth); // NOI18N

        jTableMarriage.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPaneMarriage.setViewportView(jTableMarriage);

        jTabbedPane.addTab(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveTopComponent.panelMarriage.TabConstraints.tabTitle"), new javax.swing.ImageIcon(getClass().getResource("/ancestris/modules/releve/images/Marriage.png")), jScrollPaneMarriage); // NOI18N

        jTableDeath.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPaneDeath.setViewportView(jTableDeath);

        jTabbedPane.addTab(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveTopComponent.panelDeath.TabConstraints.tabTitle"), new javax.swing.ImageIcon(getClass().getResource("/ancestris/modules/releve/images/Death.png")), jScrollPaneDeath); // NOI18N

        jTableMisc.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPaneMisc.setViewportView(jTableMisc);

        jTabbedPane.addTab(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveTopComponent.panelMisc.TabConstraints.tabTitle"), new javax.swing.ImageIcon(getClass().getResource("/ancestris/modules/releve/images/misc.png")), jScrollPaneMisc); // NOI18N

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        jPanelConfig.add(jTabbedPane, gridBagConstraints);
        jTabbedPane.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveTopComponent.panelMisc.TabConstraints.tabTitle")); // NOI18N

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        getContentPane().add(jPanelConfig, gridBagConstraints);

        jPanelFirstName.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jPanelFirstName.setLayout(new java.awt.GridBagLayout());

        jButtonOk.setText(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveEditorConfigDialog.jButtonOk.text")); // NOI18N
        jButtonOk.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOkActionPerformed(evt);
            }
        });
        jPanelFirstName.add(jButtonOk, new java.awt.GridBagConstraints());

        jButtonCancel.setText(org.openide.util.NbBundle.getMessage(ReleveEditorConfigDialog.class, "ReleveEditorConfigDialog.jButtonCancel.text")); // NOI18N
        jButtonCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCancelActionPerformed(evt);
            }
        });
        jPanelFirstName.add(jButtonCancel, new java.awt.GridBagConstraints());

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(jPanelFirstName, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        // rien à faire
    }//GEN-LAST:event_formWindowClosed

    private void jButtonOkActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOkActionPerformed
        saveConfig();
        dispose();
    }//GEN-LAST:event_jButtonOkActionPerformed

    private void jButtonCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCancelActionPerformed
        dispose();
    }//GEN-LAST:event_jButtonCancelActionPerformed
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonCancel;
    private javax.swing.JButton jButtonOk;
    private javax.swing.JPanel jPanelConfig;
    private javax.swing.JPanel jPanelFirstName;
    private javax.swing.JScrollPane jScrollPaneBirth;
    private javax.swing.JScrollPane jScrollPaneDeath;
    private javax.swing.JScrollPane jScrollPaneMarriage;
    private javax.swing.JScrollPane jScrollPaneMisc;
    private javax.swing.JTabbedPane jTabbedPane;
    private javax.swing.JTable jTableBirth;
    private javax.swing.JTable jTableDeath;
    private javax.swing.JTable jTableMarriage;
    private javax.swing.JTable jTableMisc;
    // End of variables declaration//GEN-END:variables


    private class ConfigRow {
        EditorBeanGroup group;
        EditorBeanField field;

        ConfigRow(EditorBeanGroup group, EditorBeanField field) {
            this.group = group;
            this.field = field;
        }

        ConfigRow(EditorBeanGroup group) {
            this.group = group;
            field=null;
        }

        public boolean isGroup() {
            return field== null;
        }
    }
    
    private class ConfigModel extends AbstractTableModel {
        final String columnName[] = {
            //java.util.ResourceBundle.getBundle("ancestris/modules/releve/model/Bundle").getString("model.column.Id"),
            "Champ",
            "Visible",
        };

        final Class columnClass[] = {String.class, Boolean.class};

        HashMap<Integer,ConfigRow> rowList= new HashMap<Integer,ConfigRow>();

        ConfigModel(RecordType recordType) {
            // je recupere la liste des valeurs existantes
            int row =0;
            for (Iterator<EditorBeanGroup> groupIter = EditorBeanGroup.getGroups(recordType).iterator(); groupIter.hasNext(); ) {
                EditorBeanGroup group = groupIter.next();
                rowList.put(row++, new ConfigRow(group));
                for (Iterator<EditorBeanField> fieldIter = group.getFields().iterator(); fieldIter.hasNext(); ) {
                    rowList.put(row++, new ConfigRow(group, fieldIter.next() ));
                }
            }
        }

        public boolean isGroup(int row) {
            return rowList.get(row).isGroup();
        }

        @Override
        public int getColumnCount() {
            return columnClass.length;
        }

        @Override
        public String getColumnName(int col) {
            return columnName[col];
        }

        @Override
        public Class<?> getColumnClass(int col) {
            return columnClass[col];
        }

        @Override
        public int getRowCount() {
            return rowList.size();
        }


        @Override
        public Object getValueAt(int row, int col) {
            ConfigRow configRow = rowList.get(row);
            if (configRow.isGroup() ) {
                switch (col) {
                    case 0:
                        return configRow.group.getTitle();
                    default:
                        return null;
                }
            } else {
                switch (col) {
                    case 0:
                        return configRow.field.getLabel();
                    case 1:
                        return configRow.field.isUsed() ? configRow.field.isVisible() : null;
                    default:
                        return null;
                }
            }
        }

        @Override
        public boolean isCellEditable(int row, int col) {
            ConfigRow configRow = rowList.get(row);
            if (configRow.isGroup() ) {
                return false;
            } else {
                switch (col) {
                    case 0:
                        return false;
                    default:
                        return true;
                }
            }
        }

        @Override
        public void setValueAt(Object value, int row, int col) {
            switch (col) {
                case 1:
                    rowList.get(row).field.setVisible((Boolean)value);
                    break;
                default:
                    break;
            }
            fireTableCellUpdated(row, col);
        }


    }


    private class ConfigTable extends JTable {
        /**
     * cet methode masque les check box inutiles dans la colonne 2
     * @param renderer
     * @param row
     * @param column
     * @return
     */
        @Override
        public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {
            Component c = super.prepareRenderer(renderer, row, column);
            Object cr = ((ConfigModel) getModel()).getValueAt(row, column);
            if (column > 0 && cr == null) {
                    JLabel label = new JLabel("");
                    label.setOpaque(true);
                    if ( ((ConfigModel) getModel()).isGroup(row)) {
                         label.setBackground(greyColor);
                    } else {
                        label.setBackground(Color.WHITE);
                    }
                    return label;
                } else {
                    return c;
                }
        }

        @Override
        public Component prepareEditor(TableCellEditor editor, int row, int column) {
            Component c = super.prepareEditor(editor, row, column);
            Object cr = ((ConfigModel) getModel()).getValueAt(row, column);
            if (column > 0 && cr == null) {
                return new JLabel("");
            } else {
                return c;
            }
        }

       
    }

    /**
     * Cette classe gère l'affichage des celleules de la table
     */
    private class MergeTableRenderer extends JLabel implements TableCellRenderer {

        public MergeTableRenderer() {
            setOpaque(true);
        }

        
        /**
         *
         * @param table
         * @param value
         * @param isSelected
         * @param hasFocus
         * @param row
         * @param column
         * @return
         */
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {

            ConfigModel model = (ConfigModel) table.getModel();
            if (value != null) {
                setText(value.toString());
            } else {
                setText("");
            }
            
            
            // je choisis la couleur de fond
            if ( model.isGroup(row)) {
                setFont(table.getFont().deriveFont(Font.BOLD));
                setBackground(greyColor);
                setForeground(table.getForeground());
            } else {
                setFont(table.getFont());
                setBackground(table.getBackground());
                setForeground(table.getForeground());              
            }
            return this;

        }
    }

}
