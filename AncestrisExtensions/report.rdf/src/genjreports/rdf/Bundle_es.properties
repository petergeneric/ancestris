#            Bundle resources file for package Ancestris - Unicode
#            Path : AncestrisExtensions/report.rdf/src/genjreports/rdf

# --=====--WARNING to Translators---------------------------------=====--
#  Some lines must not be translated. If a line follow a line beginning 
#  with #NOI18N, it must be left the way it is written.
#  Using Trancestris you won't be allowed to edit it.
# --=====---------------------------------WARNING to Translators--=====--
OpenIDE-Module-Name=Informe RDF (SPARQL based)

name=SPARQL base de informes y las exportaciones
info=<h1><center>SPARQL base de informes y las exportaciones</center></h1><h2>Construido en informes</h2><p>Algunos informes, la consulta tiene un conjunto de reglas que proporciona atajos.El valor predeterminado se establece en 1. Conjunto 2 puede tardar minutos. Conjunto de 0 (cero) es un conjunto vac\u00edo.</p><ul><li>informes generales (ninguna entidad como contexto)<ol><li>Diferencia de edad grande entre marido y mujer.</li><li>Nombres de Conde.</li><li>Eventos de recuento por lugar</li></ol></li><li>Informes basados en un individuo<ol><li>L\u00ednea de tiempo con la muerte de nacimiento y matrimonio de parientes cercanos. Debe gobernar el conjunto 1.<li>Antepasados sin padres. Debe gobernar el conjunto 2.<li>Objetos multimedia de antepasados. Debe gobernar el conjunto 2. Variaci\u00f3n sugerencia: quitar la l\u00ednea "? p:id indi '% s'; r: antepasado? a. "para hacerla gedcom amplia y deshacerse de los conjuntos de reglas.<li>L\u00edneas de migraci\u00f3n por rama. Debe gobernar el conjunto 2.</li></li></li></li></ol><li>Informes basados en una familia<ol><li>Composici\u00f3n de una familia de mosaico.</li></ol></li></li></ul><h2>Introducci\u00f3n</h2><p>Un informe est\u00e1 configurado con dos pasos: qu\u00e9 mostrar (con una consulta SPARQL) y c\u00f3mo mostrarla (formato el dise\u00f1o). Omitir el segundo paso si las miradas no son importantes.</p><h2>Paso 1: Crear una consulta <a href="http://openjena.org/ARQ/documentation.html">SPARQL</a>(o modificar una existente)</h2><p>Puede encontrar versiones multil\u00ednea (m\u00e1s f\u00e1cil de leer para los seres humanos) de las consultas de forma predeterminada en el archivo de <a href="http://trac.arvernes.dyndns.org/ancestris/browser/trunk/AncestrisExtensions/report.rdf/src/genjreports/rdf/Bundle.properties">Propiedades</a>. Busque este archivo en su sistema para evitar conflictos de versi\u00f3n. Las consultas predeterminadas est\u00e1n dise\u00f1adas como ejemplos que muestran diversos trucos del oficio.El informe de diferencias de edad se transforma f\u00e1cilmente en un informe estad\u00edstico: colocar o invertir el filtro y seleccione s\u00f3lo "avg(?diff)".</p><p>Consulte las notas de las extensiones para las sugerencias de sintaxis.Una consulta puede comparar fechas de gregoriano completas llana.</p><p>Reglas pueden proporcionar accesos directos \u00fatiles para las consultas.Pero inform\u00e1tica antepasados y descendientes para cada individuo puede tardar minutos.Tres conjuntos de reglas son siempre conjunto 0 est\u00e1 vac\u00edo, 1 es sin antepasados y descendientes, conjunto 2 con.</p><h2>Paso 2: Ajustar el dise\u00f1o</h2><p>El segundo paso es una transformaci\u00f3n del resultado de la consulta en HTML (o lo que sea) con una<a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xsl">hoja de estilos xsl</a> o<a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xq">xQuery</a>, siga los v\u00ednculos para descargar ejemplos que generan un dise\u00f1o de tabla HTML normal.Las opciones permiten poner su copia de la hoja de estilo en el archivo XML generado.Una hoja de estilos XSL y el resultado de la consulta deben publicarse en el mismo dominio.Para xQuery es necesario poner el nombre del archivo XML generado en el archivo de xQuery.</p><h2>Opciones</h2><h3>URI para entidades</h3><p>Para habilitar las consultas SPARQL, el gedcom necesita una conversi\u00f3n.El nuevo formato requiere para activar el ID en URI.URI puede parecer URL, pero son <em>identificadores</em>de recursos universal, no hace falta, pero puede <em>localizar</em> una p\u00e1gina web real.Si los formatos son \u00fanicos por gedcom, puede pegar los gedcoms convertidos para consultar con otra herramienta SPARQL.</p><h3>Salida</h3>El panel de informe recibe al menos informaci\u00f3n de progreso (v\u00e9anse las notas de rendimiento por informe) y mensajes de error.<p>nombre de archivo de salida</p><ul><li><strong>Claro</strong> el campo para obtener un cuadro de di\u00e1logo para examinar el sistema de archivos.<li>S\u00f3lo un <strong>\#render</strong> la salida del informe panel, buena para desarrollar una consulta de paso a paso. El panel de informe tambi\u00e9n permite la integraci\u00f3n de GUI: seleccione una entidad a trav\u00e9s del informe<li><strong>{0}</strong> es reemplazado con el identificador de la entidad para la que se ejecuta el informe</li></li></li></ul><p>extensiones se puede convertir gedcom</p><p>La extensi\u00f3n n3 y ttl mucho tienen en com\u00fan con SPARQL, para examinar el gedcom convertido puede ayudar a escribir y personalizar consultas.El gedcom no se convierte en cualquier ontolog\u00eda RDF espec\u00edfico.La conversi\u00f3n se realiza s\u00f3lo en forma sint\u00e1ctica de 1:1, por lo que el resultado es similar al modo de gedcom de Ancestris Editar vista.</p><h3>Consultas</h3>Puede escribir una consulta (o conjunto de reglas) directamente en el campo de opci\u00f3n, especifique un archivo que contiene una consulta o seleccione una consulta por su n\u00famero.Un '% s' en una consulta es un marcador de posici\u00f3n para el identificador de la entidad desde que se lanz\u00f3 el informe.<p><h2>Hacer</h2><ul><li>Poner los archivos jar de<a href="http://sourceforge.net/projects/jena/files/Jena/Jena-2.6.4/">jena-2.6.4.zip</a> en la ruta de clases.</li><li>Hacer m\u00e1s fechas totalmente comparables.</li><li>ID de Propably devueltos por una consulta SPAQRQL podr\u00eda utilizarse como un filtro de exportaci\u00f3n.</li></ul><h2>Revisiones</h2><ul><li>0,6 - 02 De octubre de 2011: cambiar opciones para especificar los archivos de salida.Nuevo informe: objetos Multimedia de ancestorsThough all\u00ed no pueden ser consultas predeterminadas, puede configurar informes de todos los tipos de entidades.Cambiar el nombre a SPARQL como modelo base podr\u00eda causar confusi\u00f3n con la vista de \u00e1rbol.P:value ha cambiado a URI de espacio de nombres de rdfs:labelChanged</li><li>0,5 - 11 De mayo de 2011: conjunto de reglas con antepasados y descendientes.</li><li>0,4 - 03 De mayo de 2011: permitir m\u00faltiples construido en las consultas.</li><li>0.3 - 03 De mayo de 2011: reemplazada informe predeterminado. Nuevo: muestran diferencias grandes de edad. Fue: nombres de Conde.</li><li>0,2 - 02 De mayo de 2011: un ligero cambio en formateo las fechas y las partes de nombre. Reglas activadas</li><li>0.1 - 25 De abril de 2011: inicial de revisi\u00f3n</li></ul>


#  option labels ########################
uriFormats=formato de entidad de URIs ({0} es un marcador de posici\u00f3n para id)

fam=familia
indi=Individuo
obje=objeto
note=nota
sour=fuente
repo=repositorio
subm=remitente

output=salida: d\u00f3nde y c\u00f3mo escribir convertidos de gedcom y/o resultados consulta

styleSheet=nombre del archivo de hoja de estilo XSL para incrustar en el resultado XML
reuseConversion=leer una conversi\u00f3n guardada anteriormente
convertedFileName=nombre de archivo de gedcom convierte a n3/nt/ttl/rdf
reportFileName=nombre del archivo de salida (opcional, extensiones xml/txt)
askForOverwrite=Preguntar antes de sobrescribir archivos existentes

queries=Consultas SPARQL (consulta, nombre de archivo o n\u00famero de construido en consulta; ver info)

qFam=contexto de la consulta es familia
qIndi=contexto de la consulta es individual
qMedia=contexto de la consulta es objeto de m\u00faltiples medios de comunicaci\u00f3n
qNote=contexto de la consulta es nota
qSource=contexto de la consulta es fuente
qRepository=contexto de la consulta es repositorio
qSubmitter=contexto de la consulta es remitente
qGedcom=la consulta es sobre gedcom completa
qRules=reglas o atajos


#  optional dialog ######################
overwrite.question={0} ya existe. \u00bfSobrescribirlo?


#  messages #############################


#  {0} is replaced with a file name
progress.writing=escribir {0}


#  below no further translations   #######
query.function.prefixes=\nPREFIX  fn: <http://www.w3.org/2005/xpath-functions\#> \nPREFIX afn: <http://jena.hpl.hp.com/ARQ/function\#> \nPREFIX apf: <http://jena.hpl.hp.com/ARQ/property\#> \n\n

query.rules.0=

query.rules.1=[(?fam p:WIFE ?wife)   (?fam p:HUSB ?husband)->(?wife r:spouse ?husband)(?husband r:spouse ?wife)][(?fam p:HUSB ?dad )   (?fam p:CHIL ?child  )->(?dad  r:child ?child)(?child r:parent ?dad)(?child r:dad ?dad)][(?fam p:WIFE ?mom )   (?fam p:CHIL ?child  )->(?mom  r:child ?child)(?child r:parent ?mom)(?child r:mom ?mom)][(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)->(?c1 r:sibling ?c2)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:son      ?child)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:daughter ?child)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:brother ?sibling)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:sister  ?sibling)][(?indi r:spouse ?spouse)(?spouse r:dad ?fil)->(?indi r:fatherInLaw ?fil)][(?indi r:spouse ?spouse)(?spouse r:mom ?mil)->(?indi r:motherInLaw ?mil)]

query.rules.2=[(?fam p:WIFE ?wife)   (?fam p:HUSB ?husband)->(?wife r:spouse ?husband)(?husband r:spouse ?wife)][(?fam p:HUSB ?dad )   (?fam p:CHIL ?child  )->(?dad  r:child ?child)(?child r:parent ?dad)(?child r:ancestor ?dad)(?dad r:descendant ?child)][(?fam p:WIFE ?mom )   (?fam p:CHIL ?child  )->(?mom  r:child ?child)(?child r:parent ?mom)(?child r:ancestor ?mom)(?mom r:descendant ?child)][(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)->(?c1 r:sibling ?c2)][(?a r:ancestor ?b)(?b r:ancestor ?c)->(?a r:ancestor ?c)(?c r:descendant ?a)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:son      ?child)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:daughter ?child)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:brother ?sibling)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:sister  ?sibling)][(?indi r:spouse ?spouse)(?spouse r:dad ?fil)->(?indi r:fatherInLaw ?fil)][(?indi r:spouse ?spouse)(?spouse r:mom ?mil)->(?indi r:motherInLaw ?mil)]

#  large age differences between husband and wife
query.gedcom.1=SELECT (str(?idHusb) as ?idM) (?yearHusb as ?birthM) (str(?idWife)as ?idF) (?yearWife as ?birthF) ?diff{?fam p:HUSB ?husb; p:WIFE ?wife.?husb p:id ?idHusb; p:BIRT [p:DATE [rdfs:label ?dateHusb]].?wife p:id ?idWife;  p:BIRT [p:DATE [rdfs:label ?dateWife]].LET (?yearHusb := fn:substring(str(?dateHusb),0,4))LET (?yearWife := fn:substring(str(?dateWife),0,4))LET (?diff := xsd:int(?yearHusb) - xsd:int(?yearWife))FILTER (?diff > 20 || ?diff < -20)} ORDER BY ?diff
#  count first names
query.gedcom.2=SELECT count(?indi) ?first{?indi a t:INDI ; p:NAME [p:first ?first] . }GROUP BY ?first ORDER BY ?first
#  count events per place 
query.gedcom.3=SELECT ?place count(?eventType) afn:localname(?eventType){?entity ?e [a ?eventType; p:PLAC [rdfs:label ?place]]}GROUP BY ?place ?eventTypeORDER BY ?place ?eventType
#  shows the configuration of a patchwork family (remarried widow and widower)
query.fam.1=SELECT DISTINCT ?name1 ?name2 (?nameChild as ?Child)(fn:substring(str(?dateBirth),0,10) as ?born)(fn:substring(str(?dateDeath),0,10) as ?died)?age{?fam1 p:id '%s'; p:HUSB ?husb1.?indi1 p:FAMS ?fam1, ?fam2.?indi2 p:FAMS ?fam2.?fam2 p:CHIL ?child.OPTIONAL { ?child p:BIRT [p:DATE [rdfs:label ?dateBirth]] }OPTIONAL { ?child p:DEAT [p:DATE [rdfs:label ?dateDeath]] }OPTIONAL { ?child p:NAME [p:first ?nameChild] }OPTIONAL { ?indi1 p:NAME [rdfs:label ?name1] }OPTIONAL { ?indi2 p:NAME [rdfs:label ?name2] }LET (?age := xsd:int(fn:substring(str(?dateDeath),0,4)) - xsd:int(fn:substring(str(?dateBirth),0,4)) )FILTER( ?indi1 \!= ?indi2 && ?indi2 \!= ?husb1)} ORDER BY ?dateBirth

#  time line with births, deaths and marriages of close relatives
query.indi.1=SELECT DISTINCT ?alive?age(fn:substring(str(?eventDate),0,10) as ?date)(?eventType as ?event)?name{?indi p:id '%s';p:BIRT [p:DATE [rdfs:label ?birthDate]];p:DEAT [p:DATE [rdfs:label ?deathDate]].{?indi                              p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "born").}UNION{?indi                              p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "died").}UNION{?indi r:parent  ?parent.   ?parent p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "parent born").}UNION{?indi r:parent  ?parent.   ?parent p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "parent died").}UNION{?indi r:child   ?child.     ?child p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "child born").}UNION{?indi r:child   ?child.     ?child p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "child died").}UNION{?indi r:sibling ?sibling. ?sibling p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "sibling born").}UNION{?indi r:sibling ?sibling. ?sibling p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "sibling died").}UNION{?indi r:spouse  ?spouse.   ?spouse p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "spouse born").}UNION{?indi r:spouse  ?spouse.   ?spouse p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "spouse died").}UNION{?indi r:spouse  ?spouse.   ?spouse p:NAME [rdfs:label ?name]. ?indi p:FAMS ?fam. ?spouse p:FAMS ?fam. ?fam p:MARR [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "married").}UNION{?indi r:child  ?child. ?child p:FAMS ?fam; p:NAME [rdfs:label ?name]. ?fam p:MARR [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "child married").}UNION{?indi r:sibling  ?sibling. ?sibling p:FAMS ?fam; p:NAME [rdfs:label ?name]. ?fam p:MARR [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "sibling married").}LET(?eventYear := fn:substring(str(?eventDate),1,4))LET(?birthYear := fn:substring(str(?birthDate),1,4))LET(?deathYear := fn:substring(str(?deathDate),1,4))LET(?age := xsd:int(?eventYear) - xsd:int(?birthYear))LET(?alive := ?birthYear <= ?eventYear && ?eventYear <= ?deathYear)}ORDER BY ?eventDate

#  find roots
query.indi.2=SELECT str(?id) ?name{?indi p:id '%s'; r:ancestor ?a. ?a p:id ?id; p:NAME [rdfs:label ?name]. OPTIONAL {?a r:ancestor ?a2}FILTER (\!bound(?a2))} 

#  find multi media of ancestors
query.indi.3=SELECT str(?id) ?name ?event ?file{?indi p:id '%s'; r:ancestor ?a. ?a p:id ?id; p:NAME [rdfs:label ?name].{?a p:OBJE ?o. ?o p:FILE [rdfs:label ?file].} UNION {?a p:BIRT ?e.?e p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'birth')} UNION {?a p:DEAT ?e.?e p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'death')} UNION {?a p:FAMS ?f.?f p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'family')} UNION {?a p:FAMS ?f.?f p:MARR ?m. ?m p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'mariage')}FILTER( fn:contains(?file,'/familysearch/') )} ORDER BY ?name ?id ?event

#  migration lines per branch
query.indi.4=SELECT DISTINCT str(?idP) ?nameP fn:substring(str(?marriedDate),1,4) str(?idA) ?placeMarried ?placeBirth ?placeDeath ?nameA{?indi p:id       'I103'; r:ancestor ?patriarch.{?indi r:ancestor ?ancestor.?patriarch p:id ?idP; p:NAME [rdfs:label ?nameP].?ancestor  p:id ?idA; p:NAME [rdfs:label ?nameA];r:ancestor ?patriarch.OPTIONAL {?ancestor  p:FAMS ?fam.?fam       p:MARR [p:DATE [rdfs:label ?marriedDate]];p:HUSB ?husb;p:WIFE ?wife.?indi r:ancestor ?husb, ?wife;OPTIONAL { ?fam      p:MARR [ p:PLAC [rdfs:label ?placeMarried]]}}OPTIONAL { ?ancestor p:BIRT [ p:PLAC [rdfs:label ?placeBirth]]}OPTIONAL { ?ancestor p:DEAT [ p:PLAC [rdfs:label ?placeDeath]]}OPTIONAL {?patriarch r:ancestor ?a2}FILTER (\!bound(?a2))} UNION{?patriarch p:id ?idP; p:NAME [rdfs:label ?nameP].OPTIONAL {?patriarch  p:FAMS ?fam.?fam       p:MARR [p:DATE [rdfs:label ?marriedDate]; p:PLAC [rdfs:label ?placeMarried]];}OPTIONAL {?patriarch r:ancestor ?a2}FILTER (\!bound(?a2))LET (?nameA := ?nameP)LET (?idA   := ?idP)}} order by ?nameP ?married ?nameA
