// @formatter:off
/*
 * Copyright 2012, J. Pol
 *
 * This file is part of free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation.
 *
 * This package is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details. A copy of the GNU General Public License is
 * available at <http://www.gnu.org/licenses/>.
 */
// @formatter:on
package genjreports.rdf.semweb;

import static com.hp.hpl.jena.rdf.model.ResourceFactory.*;
import static genjreports.rdf.semweb.Predicate.*;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;

import com.hp.hpl.jena.rdf.model.*;

/**
 * Manager of data from the semantic web related to place name literals.
 * 
 * @author Jo Pol
 */
public class Mashup
{

    private static final Logger logger = Logger.getLogger(Mashup.class.getName());

    private final URI idPrefix;
    private final File file;

    /** output file format */
    private final String language;
    private Model model;
    private DownloadManager downloadManager;

    /**
     * Creates an object to download and link data from the semantic web for place name literals.
     * 
     * @param idPrefix
     *        used to construct new URIs.
     * @param file
     *        a file with one of the extension rdf/n3/ttl. External changes to the file between and
     *        during method invocations of this instance will be overwritten. Downloads are not refreshed
     *        for an existing file.
     * @param languages
     *        domain name prefixes for dbpedia separated with "|". For example "fr" to get the resources
     *        from fr.dbpedia.org or "fr|de" to get the French and German resources. Null or empty to
     *        just fetch the English resources.
     * @throws IOException
     */
    public Mashup(final URI idPrefix, final File file, final String languages) throws IOException
    {
        this.file = file;
        this.idPrefix = idPrefix;

        final String extension = file.getName().trim().replaceAll(".*\\.", "").toLowerCase();
        language = Extension.valueOf(extension).language();

        model = ModelFactory.createDefaultModel();
        if (file.exists())
            model.read(new FileInputStream(file), (String) null, language);
        else
            model.setNsPrefixes(Prefix.NAME_URI_MAP);
        downloadManager = new DownloadManager(model, languages);
    }

    /**
     * Links KEY-VALUE pairs and downloads related resources from the web. The following statements are
     * created:
     * 
     * <pre>
     * &lt;ID&gt; rdf:label KEY.
     * &lt;ID&gt; rdfs:isDefinedBy &lt;http://sws.geonames.org/VALUE&gt;.
     * &lt;http://sws.geonames.org/VALUE&gt; rdfs:seeAlso &lt;http://XX.dbpedia.org/YYY&gt;
     * </pre>
     * 
     * The &lt;ID&gt; is generated by extending the {@link URI} passed to the constructor. The GeoNames
     * resource is fetched if not already present. DBPedia resources are fetched when the GeoNames
     * resource refers to it with seeAlso. The third type of statement is added if the dbpedia resource
     * refers to it with a sameAs and XX is one of the desired languages.
     * 
     * @param placeNameIdMap
     *        KEY: place name literal. For gedcom files typically<br>
     *        the unique values of INDI:*:PLAC and/or FAM:*:PLAC<br>
     *        for example ", Washington, , , , DC, USA"<br>
     *        VALUE: GeoNameId's (the numeric component of the URIs)<br>
     *        uri example http://sws.geonames.org/4140963/about.rdf
     * @throws URISyntaxException
     * @throws FileNotFoundException
     *         in case the location does not exist for the {@link File} passed to the constructor, or the
     *         file is removed between checking its existence and reading it.
     */
    public void add(final Map<String, String> placeNameIdMap) throws IOException, URISyntaxException
    {
        for (final String place : placeNameIdMap.keySet())
        {
            logger.info(place);
            final String geoNameId = placeNameIdMap.get(place);
            final String geoNameUri = "http://sws.geonames.org/" + geoNameId + "/";
            final Resource subject = createResource(idPrefix + geoNameId);
            final Resource gnResource = createResource(geoNameUri);
            final Set<String> more = downloadManager.downloadGeoNames(geoNameUri);

            model.add(subject, hasLabel.toProperty(), place);
            model.add(subject, isDefinedBy.toProperty(), gnResource);
            for (final String uri : more)
            {
                if (uri.matches(".*geonames.org/.*"))
                    model.add(subject, isDefinedBy.toProperty(), createResource(uri));
                else
                    model.add(gnResource, seeAlso.toProperty(), createResource(uri));
            }
            // flush each place
            model.write(new FileOutputStream(file), language);
        }
        logger.log(Level.INFO, model.size() + " statements");
    }

    public static void main(final String[] args) throws URISyntaxException, IOException
    {
        final String message = "expected arguments: input file " + "(per line: GeoNameID, tab, place name), URI, output file";
        if (args.length < 3)
        {
            logger.log(Level.SEVERE, message);
            return;
        }
        final File inputFile = new File(args[0]);
        final URI uri = new URI(args[1]);
        final File outputFile = new File(args[2]);
        final Map<String, String> places = new HashMap<String, String>();
        final String languages = (args.length > 3 ? args[3] : "");
        final Mashup mashup = new Mashup(uri, outputFile, languages);

        final BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile)));
        String line;
        logger.log(Level.INFO, "started");
        try
        {
            while ((line = reader.readLine()) != null)
            {
                final String[] fields = line.split("\t");
                if (fields.length > 1)
                {
                    final String geoNameId = fields[0].replaceAll("[^0-9]*", "");
                    final String placeLiteral = line.substring(fields[0].length() + 1).trim();
                    if (geoNameId.length() > 0 && placeLiteral.length() > 0)
                        places.put(line.substring(fields[0].length() + 1), geoNameId);
                }
            }
            if (places.isEmpty())
                logger.log(Level.WARNING, message);
            else
                mashup.add(places);
        }
        catch (final RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            reader.close();
        }
        logger.log(Level.INFO, "finished");
    }
}
