#                  Bundle resources file for package Ancestris - Unicode
#                  Path : AncestrisExtensions/report.rdf/src/genjreports/rdf

#       --=====--WARNING to Translators---------------------------------=====--
#        Some lines must not be translated. If a line follow a line beginning 
#        with #NOI18N, it must be left the way it is written.
#        Using Trancestris you won't be allowed to edit it.
#       --=====---------------------------------WARNING to Translators--=====--
OpenIDE-Module-Name=Report RDF (SPARQL based) \n

name=Reports ed exports SPARQL
info=<h1><center>Reports ed exports SPARQL</center></h1><h2>reports interni</h2><p>Per alcuni reports la query richiede un set di regole che fornisce scorciatoie.Il default \u00e8 settato a 1. Il set 2 pu\u00f2 richiedere minuti. Il set 0 (zero) \u00e8 un set vuoto.</p><ul><li>reports generali (senza entit\u00e0 di contesto)<ol><li>Grande differenza di et\u00e0 fra marito e moglie.</li><li>Conta nomi.</li><li>Conta eventi per luogo</li></ol></li><li>Reports basati su un individuo<ol><li>Cronologia con nascite decessi e matrimoni di parenti prossimi. Richiede regole settate a 1.<li>Antenati senza genitori. Richiede settaggio 2.<li>Oggetti multimedia degli antenati. Richiede settaggio 2. Variazionet:Rimuovere la riga "?indi p:id '%s'; r:ancestor ?a." per vuotare il gedcom e liberarsi del settaggio.<li>Migrazione righe per ramo. Richiede settaggio 2.</ol></li><li>Reports basati su una famiglia<ol><li>Composizione di una famiglia a mosaico.</ol></li></ul><h2>Intro</h2><p>Un report \u00e8 configurato con due livelli: Cosa mostrare (con una query SPARQL) e come mostrarlo (stile del layout). Saltare il secondo livello se lo stile non \u00e8 importante.</p><h2>Step 1: Creare una <a href="http://openjena.org/ARQ/documentation.html">SPARQL</a>query (o modifica una esistente)</h2><p>Si possono trovare versioni multiriga (pi\u00f9 facile da leggersi per gli umani) delle querys di default nelle <a href="http://trac.arvernes.dyndns.org/ancestris/browser/trunk/AncestrisExtensions/report.rdf/src/genjreports/rdf/Bundle.properties">propriet\u00e0</a>file. Localizzare questo file nel vostro sistema per evitare conflitti di versione. Le queris di default vanno intese come esempi che mostrano i vari trucchi del mestiere.Il report di differenza d'et\u00e0 viene facilmente convertito in un report statistico: scarta o inverti il filtro e seleziona esattamente "avg(?diff)".</p><p>Consulta le note di estensione per per l'uso della sintassi.Una query pu\u00f2 comparare chiaramente date Gregoriane.</p><p>Le regole possono fornire pratiche scorciatoie per le queryes.Ma calcolando gli antenati ed i discendenti di ogni individuo pu\u00f2 richiedere minuti.Cos\u00ec vengono forniti tre set di regole, set 0 \u00e8 vuoto, set 1 i\u00e8 senza antenati e discendenti, set 2 invece \u00e8 con.</p><h2>Livello 2: Trasforma il layout</h2><p>Il secondo passaggio \u00e8 la trasformazione del risultato della query in HTML (o altro) con un<a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xsl">foglio xsl style</a> o<a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xq">xQuery</a>, seguite i links per scaricare esempi che generano una semplice tabella HTML .le opzioni permettono di porre la vostra copia del foglio di stile nel file XML generato.Un foglio XSL style ed i risultati della query devono venir pubblicati nello stesso dominio.Per l' xQuery bisogna mettere il nome del file XML generato nel file  xQuery.</p><h2>Opzioni</h2><h3>URI's per entit\u00e0</h3><p>Per attivare le queries SPARQL, il gedcom deve essere convertito.Il nuovo formato richiede di commutare le ID's in URI's.URI's possono sembrare come URL's, ma esse sono risorse universali <em>identifiers</em>, esse non devono ma possono <em>localizzare</em>una reale pagina web.se i formati sono unici per gedcom, si possono incollare i gedcom convertiti assieme per interrogarli con un altro strumento SPARQL .</p><h3>Output</h3>Il pannello del report riceve almeno informazioni sul progresso (cfr.le note di prestazione per report) ed i messaggi di errore.<p>nome del file di output</p><ul><li><strong>Pulire</strong> il campo per aprire un dialogo per scartabellare il file system.<li>Proprio un <strong>\#</strong> produce l' output sul pannello del report, valido per sviluppare una query passo passo. Il pannello del report permette anche una integrazione GUI: selezionare una entit\u00e0 all'interno del report<li><strong>{0}</strong> \u00e8 rimpiazzata con l' id dell'entit\u00e0 per cui il report  \u00e8 eseguito</li></ul><p>estensioni gedcom convertite</p><p>l' estensione n3 e ttl hanno molto in comune con SPARQL,per cui esaminare il gedcom convertito pu\u00f2 essere utile per scrivere queries customizzate.Il gedcom non \u00e8 convertito in alcuna pecifica ontologia RDF.La conversione \u00e8 fatta solamente in modo sintattico 1:1 , per cui il risultato \u00e8 simile al modo gedcom della vista di edizione di Ancestris.</p><h3>Queries</h3>Potete scrivere una query (o un set di regole) direttamente nel campo opzioni, specificando un file che contiene la query o selezionando una query interna per il numero.A '%s' in una query \u00e8 spazio contenente l' id dell'entit\u00e0 da cui il report \u00e8 stato lanciato.</p><h2>To do</h2><ul><li>Porre i files jar di<a href="http://sourceforge.net/projects/jena/files/Jena/Jena-2.6.4/">jena-2.6.4.zip</a>nella classpath.</li><li>Rendi altre date completamente comparabili.</li><li>Probabilmente le ID's restituite da una query SPAQRQL possono esere usate come un filtro export.</li></ul><h2>Revisioni</h2><ul><li>0.6 - 2 Oct 2011: changed options to specify output files.New report: Multimedia objects of ancestorsThough there may not be default queries, you can configure reports for all the types of entities.Renamed to SPARQL based as blueprint based might cause confusion with the tree view.Changed p:value to rdfs:labelChanged name space URIs</li><li>0.5 - 11 May 2011: rule set with ancestors and descendants.</li><li>0.4 - 3 May 2011: Allow for multiple built in queries.</li><li>0.3 - 3 May 2011: Replaced default report. New: show large age differences. Was: count names.</li><li>0.2 - 2 May 2011: A slight change in formating the dates and name parts. Enabled rules</li><li>0.1 - 25 April 2011: Initial revision</li></ul>

fam=famiglia
indi=individuo
obje=oggetto
note=nota
sour=fonte
repo=deposito
subm=mittente

output=output: dove e come scrivere gli gedcom convertiti e/o i risultati delle query

styleSheet=nome del file del foglio tipo XSL da includere nel risultante XML
reuseConversion=leggere una precedente conversione salvata
convertedFileName=nome del file del gedcom convertito in n3/nt/ttl/rdf
reportFileName=nome del file di output (opzionale, estensioni xml/txt)
askForOverwrite=chiedere prima di sovrascrivere files esistenti

queries=SPARQL queries (query, nome del file, o numero della query interna; cfr. info)

qFam=il contesto della query \u00e8 la famiglia
qIndi=il contesto della query \u00e8 l' individuo
qMedia=il contesto della query \u00e8 l' oggetto multimedia
qNote=il contesto della query \u00e8 la nota
qSource=il contesto della query \u00e8 la fonte
qRepository=il contesto della query \u00e8 il deposito
qSubmitter=il contesto della query \u00e8 il mittente
qGedcom=la query riguarda un gedcom completo
qRules=regole o scorciatoie


#        optional dialog ######################
overwrite.question={0} esiste gi\u00e0. Sovrascriverlo?


#        messages #############################


#        {0} is replaced with a file name
progress.writing=scrivendo {0}


#        below no further translations   #######
query.function.prefixes=\nPREFIX  fn: <http://www.w3.org/2005/xpath-functions\#> \nPREFIX afn: <http://jena.hpl.hp.com/ARQ/function\#> \nPREFIX apf: <http://jena.hpl.hp.com/ARQ/property\#>  \n\n

query.rules.1=[(?fam p:WIFE ?wife)   (?fam p:HUSB ?husband)->(?wife r:spouse ?husband)(?husband r:spouse ?wife)][(?fam p:HUSB ?dad )   (?fam p:CHIL ?child  )->(?dad  r:child ?child)(?child r:parent ?dad)(?child r:dad ?dad)][(?fam p:WIFE ?mom )   (?fam p:CHIL ?child  )->(?mom  r:child ?child)(?child r:parent ?mom)(?child r:mom ?mom)][(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)->(?c1 r:sibling ?c2)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:son      ?child)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:daughter ?child)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:brother ?sibling)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:sister  ?sibling)][(?indi r:spouse ?spouse)(?spouse r:dad ?fil)->(?indi r:fatherInLaw ?fil)][(?indi r:spouse ?spouse)(?spouse r:mom ?mil)->(?indi r:motherInLaw ?mil)]

query.rules.2=[(?fam p:WIFE ?wife)   (?fam p:HUSB ?husband)->(?wife r:spouse ?husband)(?husband r:spouse ?wife)][(?fam p:HUSB ?dad )   (?fam p:CHIL ?child  )->(?dad  r:child ?child)(?child r:parent ?dad)(?child r:ancestor ?dad)(?dad r:descendant ?child)][(?fam p:WIFE ?mom )   (?fam p:CHIL ?child  )->(?mom  r:child ?child)(?child r:parent ?mom)(?child r:ancestor ?mom)(?mom r:descendant ?child)][(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)->(?c1 r:sibling ?c2)][(?a r:ancestor ?b)(?b r:ancestor ?c)->(?a r:ancestor ?c)(?c r:descendant ?a)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:son      ?child)][(?parent r:child ?child)(?child p:SEX ?sex)(?sex rdfs:label "M")->(?parent r:daughter ?child)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:brother ?sibling)][(?indi r:sibling ?sibling)(?sibling p:SEX ?sex)(?sex rdfs:label "M")->(?indi r:sister  ?sibling)][(?indi r:spouse ?spouse)(?spouse r:dad ?fil)->(?indi r:fatherInLaw ?fil)][(?indi r:spouse ?spouse)(?spouse r:mom ?mil)->(?indi r:motherInLaw ?mil)]

#        large age differences between husband and wife
query.gedcom.1=SELECT (str(?idHusb) as ?idM) (?yearHusb as ?birthM) (str(?idWife)as ?idF) (?yearWife as ?birthF) ?diff{?fam p:HUSB ?husb; p:WIFE ?wife.?husb p:id ?idHusb; p:BIRT [p:DATE [rdfs:label ?dateHusb]].?wife p:id ?idWife;  p:BIRT [p:DATE [rdfs:label ?dateWife]].LET (?yearHusb := fn:substring(str(?dateHusb),0,4))LET (?yearWife := fn:substring(str(?dateWife),0,4))LET (?diff := xsd:int(?yearHusb) - xsd:int(?yearWife))FILTER (?diff > 20 || ?diff < -20)} ORDER BY ?diff
#        count first names
query.gedcom.2=SELECT count(?indi) ?first{?indi a t:INDI ; p:NAME [p:first ?first] . }GROUP BY ?first ORDER BY ?first 
#        count events per place 
query.gedcom.3=SELECT ?place count(?eventType) afn:localname(?eventType){?entity ?e [a ?eventType; p:PLAC [rdfs:label ?place]]}GROUP BY ?place ?eventTypeORDER BY ?place ?eventType
#        shows the configuration of a patchwork family (remarried widow and widower)
query.fam.1=SELECT DISTINCT ?name1 ?name2 (?nameChild as ?Child)(fn:substring(str(?dateBirth),0,10) as ?born)(fn:substring(str(?dateDeath),0,10) as ?died)?age{?fam1 p:id '%s'; p:HUSB ?husb1.?indi1 p:FAMS ?fam1, ?fam2.?indi2 p:FAMS ?fam2.?fam2 p:CHIL ?child.OPTIONAL { ?child p:BIRT [p:DATE [rdfs:label ?dateBirth]] }OPTIONAL { ?child p:DEAT [p:DATE [rdfs:label ?dateDeath]] }OPTIONAL { ?child p:NAME [p:first ?nameChild] }OPTIONAL { ?indi1 p:NAME [rdfs:label ?name1] }OPTIONAL { ?indi2 p:NAME [rdfs:label ?name2] }LET (?age := xsd:int(fn:substring(str(?dateDeath),0,4)) - xsd:int(fn:substring(str(?dateBirth),0,4)) )FILTER( ?indi1 \!= ?indi2 && ?indi2 \!= ?husb1)} ORDER BY ?dateBirth

#        time line with births, deaths and marriages of close relatives
query.indi.1=SELECT DISTINCT ?alive?age(fn:substring(str(?eventDate),0,10) as ?date)(?eventType as ?event)?name{?indi p:id '%s';p:BIRT [p:DATE [rdfs:label ?birthDate]];p:DEAT [p:DATE [rdfs:label ?deathDate]].{?indi                              p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "born").}UNION{?indi                              p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "died").}UNION{?indi r:parent  ?parent.   ?parent p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "parent born").}UNION{?indi r:parent  ?parent.   ?parent p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "parent died").}UNION{?indi r:child   ?child.     ?child p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "child born").}UNION{?indi r:child   ?child.     ?child p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "child died").}UNION{?indi r:sibling ?sibling. ?sibling p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "sibling born").}UNION{?indi r:sibling ?sibling. ?sibling p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "sibling died").}UNION{?indi r:spouse  ?spouse.   ?spouse p:NAME [rdfs:label ?name]; p:BIRT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "spouse born").}UNION{?indi r:spouse  ?spouse.   ?spouse p:NAME [rdfs:label ?name]; p:DEAT [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "spouse died").}UNION{?indi r:spouse  ?spouse.   ?spouse p:NAME [rdfs:label ?name]. ?indi p:FAMS ?fam. ?spouse p:FAMS ?fam. ?fam p:MARR [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "married").}UNION{?indi r:child  ?child. ?child p:FAMS ?fam; p:NAME [rdfs:label ?name]. ?fam p:MARR [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "child married").}UNION{?indi r:sibling  ?sibling. ?sibling p:FAMS ?fam; p:NAME [rdfs:label ?name]. ?fam p:MARR [p:DATE [rdfs:label ?eventDate]]. LET (?eventType := "sibling married").}LET(?eventYear := fn:substring(str(?eventDate),1,4))LET(?birthYear := fn:substring(str(?birthDate),1,4))LET(?deathYear := fn:substring(str(?deathDate),1,4))LET(?age := xsd:int(?eventYear) - xsd:int(?birthYear))LET(?alive := ?birthYear <= ?eventYear && ?eventYear <= ?deathYear)}ORDER BY ?eventDate

#        find roots
query.indi.2=SELECT str(?id) ?name{?indi p:id '%s'; r:ancestor ?a. ?a p:id ?id; p:NAME [rdfs:label ?name]. OPTIONAL {?a r:ancestor ?a2}FILTER (\!bound(?a2))} 

#        find multi media of ancestors
query.indi.3=SELECT str(?id) ?name ?event ?file{?indi p:id '%s'; r:ancestor ?a. ?a p:id ?id; p:NAME [rdfs:label ?name].{?a p:OBJE ?o. ?o p:FILE [rdfs:label ?file].} UNION {?a p:BIRT ?e.?e p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'birth')} UNION {?a p:DEAT ?e.?e p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'death')} UNION {?a p:FAMS ?f.?f p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'family')} UNION {?a p:FAMS ?f.?f p:MARR ?m. ?m p:OBJE ?o. ?o p:FILE [rdfs:label ?file].LET (?event := 'mariage')}FILTER( fn:contains(?file,'/familysearch/') )} ORDER BY ?name ?id ?event

#        migration lines per branch
query.indi.4=SELECT DISTINCT str(?idP) ?nameP fn:substring(str(?marriedDate),1,4) str(?idA) ?placeMarried ?placeBirth ?placeDeath ?nameA{?indi p:id       'I103'; r:ancestor ?patriarch.{?indi r:ancestor ?ancestor.?patriarch p:id ?idP; p:NAME [rdfs:label ?nameP].?ancestor  p:id ?idA; p:NAME [rdfs:label ?nameA];r:ancestor ?patriarch.OPTIONAL {?ancestor  p:FAMS ?fam.?fam       p:MARR [p:DATE [rdfs:label ?marriedDate]];p:HUSB ?husb;p:WIFE ?wife.?indi r:ancestor ?husb, ?wife;OPTIONAL { ?fam      p:MARR [ p:PLAC [rdfs:label ?placeMarried]]}}OPTIONAL { ?ancestor p:BIRT [ p:PLAC [rdfs:label ?placeBirth]]}OPTIONAL { ?ancestor p:DEAT [ p:PLAC [rdfs:label ?placeDeath]]}OPTIONAL {?patriarch r:ancestor ?a2}FILTER (\!bound(?a2))} UNION{?patriarch p:id ?idP; p:NAME [rdfs:label ?nameP].OPTIONAL {?patriarch  p:FAMS ?fam.?fam       p:MARR [p:DATE [rdfs:label ?marriedDate]; p:PLAC [rdfs:label ?placeMarried]];}OPTIONAL {?patriarch r:ancestor ?a2}FILTER (\!bound(?a2))LET (?nameA := ?nameP)LET (?idA   := ?idP)}} order by ?nameP ?married ?nameA
