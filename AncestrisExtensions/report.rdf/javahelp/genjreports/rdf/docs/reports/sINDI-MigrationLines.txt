###############################################
#
# Migration lines (a slow query).
#
# replace the value for idOfRootIndi
# or launch from a family context
#
# the slow rules are required
#
# It would be great to turn it into a KML file that
# draws lines from # the patriarchs to the root of the tree.
# The algorithm would have to deal with gaps.
#
# the query might get faster by using the custom label _TREETOP
# but that would complicate execution
#
###############################################

SELECT DISTINCT 
  (str(?idP) as ?id_of_patriarch)
# (str(?idA) as ?id_of_ancestor)
# (?nameP    as ?name_of_patriarch)
  (?nameA    as ?name_of_ancestor)
  (fn:substring(str(?marriedDate),1,4) as ?year_married)
  ?placeMarried 
  ?placeBirth 
  ?placeDeath 
{
   ### for which individual do you want the report?
   LET (?idOfRootIndi := '%s')

   ### we want data from root to patriarchs
   ?indi p:id       ?idOfRootIndi;
         r:ancestor ?patriarch.

   ### the persons between the root an its patriarchs
   {
     ?indi r:ancestor ?ancestor.
     ?patriarch p:id ?idP; p:NAME [rdfs:label ?nameP].
     ?ancestor  p:id ?idA; p:NAME [rdfs:label ?nameA];
                r:ancestor ?patriarch.
     OPTIONAL {
       ?ancestor  p:FAMS ?fam.
       ?fam       p:MARR [p:DATE [rdfs:label ?marriedDate]];
                  p:HUSB ?husb;
                  p:WIFE ?wife.
       ?indi r:ancestor ?husb, ?wife;
       OPTIONAL { ?fam      p:MARR [ p:PLAC [rdfs:label ?placeMarried]]}
     }
     OPTIONAL { ?ancestor p:BIRT [ p:PLAC [rdfs:label ?placeBirth]]}
     OPTIONAL { ?ancestor p:DEAT [ p:PLAC [rdfs:label ?placeDeath]]}

     ### a patriarch is an ancestors without an ancestor
     OPTIONAL {?patriarch r:ancestor ?a2}
     FILTER (!bound(?a2))

     ### switch of if you don't store GIVN and SURN separately
     FILTER( fn:contains(?nameP,'/') && fn:contains(?nameA,'/') )
   } 
   UNION ### we also want the places of the patriarchs 
   {
     ?patriarch p:id ?idP;
                p:NAME [rdfs:label ?nameP].
     OPTIONAL {
       ?patriarch  p:FAMS ?fam.
       ?fam       p:MARR [p:DATE [rdfs:label ?marriedDate];
                          p:PLAC [rdfs:label ?placeMarried]
                         ];
     }

     ### a patriarch is an ancestors without an ancestor
     OPTIONAL {?patriarch r:ancestor ?a2}
     FILTER (!bound(?a2))

     ### switch of if you don't store GIVN and SURN separately
     FILTER( fn:contains(?nameP,'/')  )

     LET (?nameA := ?nameP)
     LET (?idA   := ?idP)
   }
 } order by ?nameP ?marriedDate ?nameA