###############################################
#
# timeline with all ex- and later spouses with their children
#
# replace the value for the famID
# or launch from a family context
#
# no rules required (but it won't harm)
#
# BUG: couples without children don't appear
#      see also comments on GIVN/SURN
#
###############################################
SELECT DISTINCT 

  ### default columns
  #
  (?name1 as ?parent_1)
  (?name2 as ?parent_2)
  (?nameChild as ?Child)
  (fn:substring(str(?dateBirth),0,10) as ?born)
  (fn:substring(str(?dateDeath),0,10) as ?died)
  ?age

  ### alternative Français
  #
  # (?name1 as ?parent_1)
  # (?name2 as ?parent_2)
  # (?nameChild as ?enfant)
  # (fn:substring(str(?dateBirth),0,10) as ?né)
  # (fn:substring(str(?dateDeath),0,10) as ?mort)
  # ?âge
{
  ### select the central family

  LET (?famID := '%s')

  ### select data that is allways available

  ?fam1  p:id   ?famID;
         p:WIFE ?wife.
  ?indi1 p:FAMS ?fam1,
                ?fam2.
  ?indi2 p:FAMS ?fam2.
  ?fam2  p:CHIL ?child.

  ### select data that might not be available

  OPTIONAL { ?child p:BIRT [p:DATE [rdfs:label ?dateBirth]] }
  OPTIONAL { ?child p:DEAT [p:DATE [rdfs:label ?dateDeath]] }
  OPTIONAL { ?indi1 p:NAME [rdfs:label ?name1] }
  OPTIONAL { ?indi2 p:NAME [rdfs:label ?name2] }

  ### not sure this works if you don't store GIVN and SURN separately
  OPTIONAL { ?child p:NAME [p:GIVN [rdfs:label ?nameChild]] }
  OPTIONAL { ?child p:NAME [p:first ?nameChild] }

  ### computations

  LET (?yearDeath := fn:substring(str(?dateDeath),0,4))
  LET (?yearBirth := fn:substring(str(?dateBirth),0,4))
  LET (?age := xsd:int(?yearDeath) - xsd:int(?yearBirth ))

  ### required filter

  FILTER( ?indi1 != ?indi2 && ?indi2 != ?wife )

  ### switch of if you don't store GIVN and SURN separately
  FILTER( (fn:contains(?name1,'/') || !bound(?name1))&& (fn:contains(?name2,'/') || !bound(?name2))  )

} 
 ORDER BY ?dateBirth