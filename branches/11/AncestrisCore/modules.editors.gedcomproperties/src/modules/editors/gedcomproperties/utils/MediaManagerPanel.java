/*
 * Ancestris - http://www.ancestris.org
 * 
 * Copyright 2017 Ancestris
 * 
 * Author: Frédéric Lapeyre (frederic@ancestris.org).
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
package modules.editors.gedcomproperties.utils;

import ancestris.util.swing.DialogManager;
import genj.gedcom.PropertyFile;
import genj.util.Registry;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellRenderer;
import static modules.editors.gedcomproperties.GedcomPropertiesMediaFormatPanel.ABSOLUTE;
import org.openide.util.NbBundle;

/**
 *
 * @author frederic
 */
public class MediaManagerPanel extends javax.swing.JPanel {

    private Registry registry = null;
    private String rootPath = "";
    
    private Map<PropertyFile, String> property2PathMap = null;
    private Set<PathData> pathDataList = null;
    private boolean mapModified = false;
    
    private MediaPathTableModel mptm = null;
    
    /**
     * Creates new form MediaManagerPanel
     */
    public MediaManagerPanel(String rootPath, Map<PropertyFile, String> property2PathMap) {
        this.rootPath = rootPath;
        this.property2PathMap = property2PathMap;
        registry = Registry.get(getClass());
        mapModified = false;
        
        // Build table
        pathDataList = buildTable();
        mptm = new MediaPathTableModel(this, pathDataList, rootPath);

        // Init panel
        initComponents();
        
        // Set window size
        this.setPreferredSize(new Dimension(registry.get("mediaManagerWindowWidth", this.getPreferredSize().width), registry.get("mediaManagerWindowHeight", this.getPreferredSize().height)));

        // Display table
        displayTable();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane2 = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        table = new javax.swing.JTable();

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(MediaManagerPanel.class, "MediaManagerPanel.jLabel1.text")); // NOI18N

        jLabel2.setFont(new java.awt.Font("DejaVu Sans", 1, 12)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, rootPath);

        table.setAutoCreateRowSorter(true);
        table.setModel(mptm);
        table.setPreferredSize(new java.awt.Dimension(200, 64));
        jScrollPane1.setViewportView(table);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 140, Short.MAX_VALUE)
                .addContainerGap())
        );

        jScrollPane2.setViewportView(jPanel1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane2)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        registry.put("mediaManagerWindowWidth", evt.getComponent().getWidth());
        registry.put("mediaManagerWindowHeight", evt.getComponent().getHeight());
        resizeColumns();
    }//GEN-LAST:event_formComponentResized


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTable table;
    // End of variables declaration//GEN-END:variables

    private Set<PathData> buildTable() {
        Set<PathData> ret = new TreeSet<>();
        
        for (PropertyFile pFile : property2PathMap.keySet()) {
            // Build key from value and existence
            if (pFile.isIsRemote()) {
                continue;
            }
            final File localFile = new File(pFile.getValue());
            final String name = localFile.getName();
            final String newPath = property2PathMap.get(pFile);
            final boolean rel = !ABSOLUTE.matcher(newPath).matches();
            final File f = new File(rel ? rootPath + File.separator + newPath + name : newPath + name);
            final boolean found = f.exists();
            final String key = newPath + (found ? "1" : "0");

            // Get corresponding PathData for key, and if exists, add file to it, otherwiose create pathdata altogether
            PathData pd = getPathData(ret, key);
            if (pd == null) {
                pd = new PathData(found, rel, pFile, newPath);
                ret.add(pd);
            } else {
                pd.addFile(pFile);
            }
        }
        return ret;
    }

    private PathData getPathData(Set<PathData> set, String key) {
        for (PathData pd : set) {
            if (key.equals(pd.getKey())) {
                return pd;
            }
        }
        return null;
    }

    public void updateMap(int row, String newPath) {
        // Identify row in pathDataList
        PathData pd = getPathDataFromRow(row);
        
        // Get all pFiles corresponding to it and assign to them the newPath in the map
        updateMapPathData(pd, newPath);
    }

    private void updatePathDataList(PathData pd, String path, boolean rel) {
        Path rootbase = Paths.get(rootPath);
        Path newpath = Paths.get(path);
        String newPath = path;
        if (rel) {
            Path relativePath = rootbase.relativize(newpath);
            newPath = relativePath.toString() + File.separator;
        }
        
        updateMapPathData(pd, newPath);
        
        pathDataList = buildTable();
        mptm.resetData(pathDataList);
        mptm.fireUpdateTable();
        resizeLines();
    }

    
    private PathData getPathDataFromRow(int row) {
        int i = 0;
        PathData pdRow = null;
        for (PathData pd : pathDataList) {
            pdRow = pd;
            if (i == row) {
                break;
            }
            i++;
        }
        return pdRow;
    }
    
    private void updateMapPathData(PathData pd, String newPath) {
        for (PropertyFile pFile : pd.getFiles()) {
            String previousPath = property2PathMap.get(pFile);
            if (!previousPath.equals(newPath)) {
                mapModified = true;
                property2PathMap.put(pFile, newPath);
            }
        }
    }
    
    public boolean isMapModified() {
        return mapModified;
    }
    
    
    
    private void displayTable() {
        TableCellRenderer renderer = table.getTableHeader().getDefaultRenderer();
        JLabel headerLabel = (JLabel) renderer;
        headerLabel.setHorizontalAlignment(JLabel.CENTER);

        Action action = new AbstractAction("...") {
            @Override
            public void actionPerformed(ActionEvent e) {
                JTable localtable = (JTable) e.getSource();
                AbstractTableModel model = (AbstractTableModel)localtable.getModel();
                int row = Integer.valueOf(e.getActionCommand());
                String newPath = (String) model.getValueAt(row, 2);
                Boolean rel = (Boolean) model.getValueAt(row, 4);
                PathData pdRow = getPathDataFromRow(row);
                displayNewPath(pdRow, newPath, rel);
            }
        };
        ButtonColumn bc = new ButtonColumn(table, action, 3);  // bc unsed later, no problem with that.
        
        resizeColumns();
        resizeLines();
    }
    
    private void resizeColumns() {
        Dimension size = table.getSize();
        int small = 100;
        int width = Math.max((size.width - (small * 4)), 100);
        table.getColumnModel().getColumn(0).setPreferredWidth(small); // number
        table.getColumnModel().getColumn(1).setPreferredWidth(small); // flag found
        table.getColumnModel().getColumn(2).setPreferredWidth(width); // path
        table.getColumnModel().getColumn(3).setPreferredWidth(small); // button search
        table.getColumnModel().getColumn(4).setPreferredWidth(small); // flag relative
    }

    private void resizeLines() {
        int rowHeight = new JButton().getPreferredSize().height * 2;
        table.setRowHeight(rowHeight);
        Dimension preferredSize = table.getPreferredSize();
        preferredSize.height = rowHeight * mptm.getRowCount() + 1;
        table.setPreferredSize(preferredSize);
        table.revalidate();
        table.repaint();
    }
    


    private void displayNewPath(PathData pd, String path, Boolean rel) {
        SearchFilePanel panel = new SearchFilePanel(pd, rel ? rootPath + File.separator + path : path);
        Object o = DialogManager.create(NbBundle.getMessage(MediaManagerPanel.class, "MediaManagerPanel.displayPathTitle"), panel)
                .setMessageType(DialogManager.PLAIN_MESSAGE).setOptionType(DialogManager.OK_CANCEL_OPTION).show();
        if (o == DialogManager.OK_OPTION) {
            updatePathDataList(pd, panel.getNewPath(), rel);
        }
    }
}
