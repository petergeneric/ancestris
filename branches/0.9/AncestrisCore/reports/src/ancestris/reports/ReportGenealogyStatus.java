package ancestris.reports;

import genj.gedcom.*;
import genj.gedcom.time.PointInTime;
import genj.report.Report;
import java.io.File;
import java.util.*;
import org.openide.util.NbBundle;
import org.openide.util.lookup.ServiceProvider;

/**
 *
 * Ancestris - http://www.ancestris.org
 *
 * Report displays status of information found vs information to be searched for
 * each person in the tree.
 *
 * List starts with de-cujus person and goes up the tree
 *
 * This report relies on Sosa tag filled in with sosa numbers (generated by the
 * tool box for instance) (otherwise, we would need to include the code of the toolbox in this report as well).
 *
 * August 2012
 *
 * @author Frederic Lapeyre <frederic@lapeyre-frederic.com>
 *
 */
@SuppressWarnings("unchecked")
@ServiceProvider(service = Report.class)
public class ReportGenealogyStatus extends Report {

    public int maxNbOfAncestors = 512;        // limit to avoid displaying too many empty ancestors
    public boolean includeSiblings = false;   // do we want to show siblings also after each person
    public String directoryOption = "";       // directory where to look for media
    private static String SOSATAG = "_SOSA";  // sosa tag
    private static String OUI = "1";          // information found
    private static String NON = ".";          // information not found
    private static String ERR = "#";          // information found but erroneous
    private static String SEQ = "o";          // for family event MARR, indicates that kids appearance is not chronological
    private static String FIL = "S";          // source media found but not transcripted in a text tag
    private static String SPA = " ";          // space
    private static String TAB = "\t";         // tab
    private String[] placeFormat = null;
    private int sizePlaces = (placeFormat != null) ? placeFormat.length : 0;
    private Map<String, Indi> sosaList = new TreeMap();                      // stores and retrieves individuals by sosa key
    private Map<Source, String> sourceMap = new TreeMap();                   // stores and retrieves sosa used for each source
    private Map<String, String> entMap = new TreeMap();                      // stores and retrieves unreferenced sources 
    private int cntAnomaly = 0, // counter of errors
            cntOutOfSeq = 0, // counter of out of sequence
            cntKnwnSrc = 0;                   // counter of missing transcripted sources

    /**
     * Our main logic.
     */
    public void start(Gedcom gedcom) {

        // Get all individuals in a sosa list
        Collection entities = gedcom.getEntities(Gedcom.INDI);
        Property[] props;
        String sosaStr;
        for (Iterator it = entities.iterator(); it.hasNext();) {
            Indi indi = (Indi) it.next();
            props = indi.getProperties(SOSATAG);
            if (props == null) {
                continue;
            }
            for (int i = 0; i < props.length; i++) {
                Property prop = props[i];
                sosaStr = prop.getValue();
                // if option specficies not to include siblings, skip them, 
                // except for decujus because siblings of decujus are also a decujus
                // (siblings are recognized by sosa number followed by "+" or "-" and followed by d'Aboville number)
                if (!includeSiblings && (sosaStr.indexOf("+") != -1 || sosaStr.indexOf("-") != -1) && (sosaStr.indexOf("00000001") == -1)) {
                    continue;
                }
                sosaList.put(sosaStr, indi);
            }
        }
        
        // Quit if no sosa found
        if (sosaList.isEmpty()) {
            println(NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_NoSosaFound"));
            println("========");
            return;
        }
                

        // A few initialisations
        placeFormat = validatePlaceFormat(gedcom.getPlaceFormat());
        headerLine();

        // Display sosa list with the status of the data found for each entity
        int sosaCnt = 1;  // counts ancestors
        int sosaNb;       // represents the sosa number being considered
        int i = 1;        // counts the line
        for (Iterator it = sosaList.keySet().iterator(); it.hasNext();) {
            String key = (String) it.next();
            Indi indi = sosaList.get(key);
            sosaNb = getSosaNb(key);

            // start counting ancestors from above decujus
            if (sosaNb > 1) {
                sosaCnt++;
            }

            // fill in emty lines for all ancestors that are still to be discovered 
            while (sosaNb > sosaCnt && sosaCnt < maxNbOfAncestors) {
                println(emptyLine());
                sosaCnt++;
            }

            // print status of indi
            println(getLine(indi, i++, key));

            // make it easier to read by putting a line every ten lines
            if ((i / 10) * 10 == i) {
                midLine();
            }
        }

        sosaList.clear();
        sourceMap.clear();
        println(" ");
        println(" ");
        println("========");
        println(" ");



        // List sources not used or used more than once
        println(NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_sources_header"));
        println(" ");
        List ents = gedcom.getEntities();
        for (Iterator it = ents.iterator(); it.hasNext();) {
            Entity ent = (Entity) it.next();
            List ps = ent.getProperties(PropertyXRef.class);
            for (Iterator it2 = ps.iterator(); it2.hasNext();) {
                PropertyXRef xref = (PropertyXRef) it2.next();
                Entity entity = xref.getTargetEntity();
                if (entity != null) {
                    String str = entMap.get(entity.getId());
                    if (str == null) {
                        entMap.put(entity.getId(), ent.getId());
                    } else {
                        entMap.put(entity.getId(), str + "," + ent.getId());
                    }
                }
            }
        }
        for (Iterator it = ents.iterator(); it.hasNext();) {
            Entity ent = (Entity) it.next();
            String str = entMap.get(ent.getId());
            if (str == null) {
                println("   " + NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_entity_not_used") + ent.getId());
            }
            if (str != null && (numberOf(str, ",") > numberOf(str, "R")) && ent instanceof Source) {
                println("   " + NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_multiple_source") + ent.getId() + " - " + str);
            }
        }

        entMap.clear();
        println(" ");
        println(" ");
        println("========");
        println(" ");



        // Check unused media files:
        //    - Get all obje of the gedcom file
        //    - Scan specific directories an if file not in list, decare it
        //
        List<String> gedcomFiles = new ArrayList();
        entities = gedcom.getEntities();
        for (Iterator it = entities.iterator(); it.hasNext();) {
            Entity ent = (Entity) it.next();
            for (Iterator fileIt = ent.getProperties(PropertyFile.class).iterator(); fileIt.hasNext();) {
                PropertyFile file = (PropertyFile) fileIt.next();
                //println(file.getFile().getName());
                gedcomFiles.add(file.getFile().getName());
            }
        }
        File directory = new File(directoryOption);
        boolean found = false;
        if (directory != null) {
            println(NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_unused_media", directory.toString()));
            println(" ");
            found = checkDirectory(directory, gedcomFiles);
        }
        if (!found) {
            println("   " + NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_directory"));
        }
        println(" ");
        println(" ");
        println("========");
        println(" ");

        // Print error counters
        //
        println(NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_counters"));
        println(" ");
        println("   " + NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_anomalies") + " (" + ERR + ")                   : " + cntAnomaly);
        println("   " + NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_sequence") + " (" + SEQ + ")  : " + cntOutOfSeq);
        println("   " + NbBundle.getMessage(ReportGenealogyStatus.class, "TXT_source") + " (" + FIL + ") : " + cntKnwnSrc);

        println(" ");
        println(" ");
        println("========");

    } // end_of_start

    /**
     * Print header line.
     */
    private void headerLine() {
        println("Nb " + TAB + "Sosa              " + TAB + "Gen" + TAB + "Id   " + TAB + "Med" + TAB + "Birt" + SPA + "Deat" + SPA + "Marr" + SPA + "Fam  " + TAB + "Marl" + SPA + "Marc" + SPA + "Div " + TAB + "Chr " + SPA + "Buri" + SPA + "Occu" + SPA + "Resi" + SPA + "Grad" + SPA + "Even" + SPA + "Natu" + SPA + "Adop" + SPA + "Immi" + SPA + "Nom                     ");
        midLine();
    }

    /**
     * Print mid line.
     */
    private void midLine() {
        println("---" + TAB + "------------------" + TAB + "---" + TAB + "-----" + TAB + "---" + TAB + "----" + SPA + "----" + SPA + "----" + SPA + "-----" + TAB + "----" + SPA + "----" + SPA + "----" + TAB + "----" + SPA + "----" + SPA + "----" + SPA + "----" + SPA + "----" + SPA + "----" + SPA + "----" + SPA + "----" + SPA + "----" + SPA + "------------------------");
    }

    /**
     * Print empty line.
     */
    private String emptyLine() {
        return ".  " + TAB + ".                 " + TAB + ".   " + TAB + ".    " + TAB + ".  " + TAB + ".   " + SPA + ".   " + SPA + ".   " + SPA + "     " + TAB + "    " + SPA + "    " + SPA + "    " + TAB + "    " + SPA + "    " + SPA + "    " + SPA + "    " + SPA + "    " + SPA + "    " + SPA + "    " + SPA + "    " + SPA + "    " + SPA + ".                       ";
    }

    /**
     * Get line of text from indi.
     */
    private String getLine(Indi indi, int index, String sosa) {

        Property[] props;
        String line = "";

        // Number of ancestor found
        line += index;
        line += TAB;

        // Sosa nb
        line += sosa + "                     ".substring(sosa.length());
        line += TAB;

        // Génération
        int sosaNb = getSosaNb(sosa);
        line += sosaNb == 0 ? "--" : (int) (Math.log(2 * sosaNb) / Math.log(2));
        line += TAB;

        // Id
        line += indi.getId();
        line += TAB;

        // Media
        props = indi.getProperties(new TagPath("INDI:OBJE:FILE"));
        line += props == null || props.length == 0 ? NON : props.length;
        line += TAB;

        // Birth
        line += getEvent(sosa, indi, "INDI:BIRT", true);
        line += SPA;

        // Death
        line += getEvent(sosa, indi, "INDI:DEAT", sosaNb > 15); // mandatory from great-great-grand-father and above
        line += SPA;

        // Marriage
        line += getFamilies(sosa, indi, sosaNb > 1 && sosa.indexOf("-") == -1); // family mandatory from parents and above
        line += TAB;

        // Christening
        line += getEvent(sosa, indi, "INDI:CHR", false);
        line += SPA;

        // Buri
        line += getEvent(sosa, indi, "INDI:BURI", false);
        line += SPA;

        // Occupation
        line += getMultipleEvent(sosa, indi, "OCCU");
        line += SPA;

        // Residence
        line += getMultipleEvent(sosa, indi, "RESI");
        line += SPA;

        // Graduation
        line += getMultipleEvent(sosa, indi, "GRAD");
        line += SPA;

        // Even
        line += getEvent(sosa, indi, "INDI:EVEN", false);
        line += SPA;

        // Natu
        line += getEvent(sosa, indi, "INDI:NATU", false);
        line += SPA;

        // Adoption
        line += getEvent(sosa, indi, "INDI:ADOP", false);
        line += SPA;

        // Immigration
        line += getEvent(sosa, indi, "INDI:IMMI", false);
        line += SPA;

        // Name
        line += indi.getLastName() + ", " + indi.getFirstName().substring(0, Math.min(10, indi.getFirstName().length()));

        return line;
    }

    /**
     * Get sosa nb from sosa string. (extracts first digital number found when
     * going from start of string)
     */
    private int getSosaNb(String str) {

        int sosaNb;

        int start = 0, end = str.length() - 1;
        while (start <= end && !Character.isDigit(str.charAt(start))) {
            start++;
        }
        end = start;
        while ((end <= str.length() - 1) && Character.isDigit(str.charAt(end))) {
            end++;
        }
        if (end == start) {
            return 0;
        } else {
            sosaNb = (int) Integer.parseInt(str.substring(start, end));
        }

        return sosaNb;


    }

    /**
     * Get first event found given by tag. Code is made of 4 characters. - date
     * of event - place of event - source of event on 2 digits
     */
    private String getEvent(String sosa, Entity ent, String tag, boolean mandatory) {

        String line = "";

        Property prop = ent.getPropertyByPath(tag);
        if (prop == null) {
            return mandatory ? err() + err() + err() + err() : "    ";
        }

        // date
        line += isValidAndComplete(ent.getPropertyByPath(tag + ":DATE"));

        // place
        line += isValidAndComplete(ent.getPropertyByPath(tag + ":PLAC"));

        // source and text
        line += getSource(sosa, ent, tag + ":SOUR");

        return line;
    }

    /**
     * Get all events found given by tag. Code is made of 4 digits representing
     * the number of occurrences found (9 max). 
     * - number of occurrences found. 
     * - necessary element found. 
     * - source of event on 2 digits.
     * 
     * For OCCU: label is necessary : nb / nb of label found / worst source
     * For GRAD: AGNC is necessary : nb / nb of agency found / worst source
     * For RESI: ADDR is necessary : nb / nb of addr found / worst source
     * 
     */
    private String getMultipleEvent(String sosa, Entity ent, String tag) {

        String line = "";
        boolean debug = false ; //ent.getId().equalsIgnoreCase("I2507");
        boolean isOccu = tag.equalsIgnoreCase("OCCU");
        boolean isGrad = tag.equalsIgnoreCase("GRAD");
        boolean isResi = tag.equalsIgnoreCase("RESI");

        Property[] prop = ent.getProperties(tag);
        if (prop == null || prop.length == 0) {
            return "    ";
        }

        int intNbFound = 0;
        String src = "  ";
        String tmpSrc;
        for (int i = 0; i < prop.length; i++) {
            Property property = prop[i];
            // look for necessary element depending on tag
            if (isOccu) {
                String str = property.toString();
                intNbFound += (str != null && str.length() > 0) ? 1 : 0;
            }
            if (isGrad) {
                Property agency = property.getProperty("AGNC");
                intNbFound += ((agency == null) || agency.toString().length() < 1) ? 0 : 1;
            }
            if (isResi) {
                Property address = property.getProperty("ADDR");
                if (address != null) {
                    Property city = address.getProperty("CITY");
                    intNbFound += ((city == null) || city.toString().length() < 1) ? 0 : 1;
                }
            }
            // Source and text
            tmpSrc = getSource(sosa, ent, tag + ":SOUR");
            // Only overwrite if worse source. Ranking is : "OUI < NON < FIL < ERR"
            if (src.compareTo(ERR) != -1) {             // if error already detected, continue
                continue;
            }
            if (tmpSrc.compareTo(ERR) != -1) {          // if error just detected, assign to src and continue
                src = tmpSrc;
                continue;
            }
            if (src.compareTo(FIL) == -1) {             // else, if a fill yet, continue;
                src = tmpSrc;
            }
            if (tmpSrc.compareTo(FIL) != -1) {          // if fill just detected, assign to src and continue
                src = tmpSrc;
                continue;
            }
            if (src.compareTo(NON) == -1) {             // else, if a not found yet, continue;
                src = tmpSrc;
            }
            if (tmpSrc.compareTo(NON) != -1) {          // if not found now just detected, assign to src and continue
                src = tmpSrc;
                continue;
            }
        }

        // Now, write codes
        line += prop.length == 0 ? NON : String.valueOf(prop.length);
        line += intNbFound == 0 ? NON : String.valueOf(intNbFound);
        line += src;
        return line;
    }

    /**
     * Get source code of an event. Code is made of 2 digits. - source : source
     * entity exists and has not already been attached to another event) -
     * source proof : a text or media has been found) Rules: - If a source has a
     * media then the text should be filled in - If two sources are attached to
     * an event, only the first one is detected - A source can only be attached
     * once to n individual
     */
    private String getSource(String sosa, Entity ent1, String tag) {

        String src = "";
        Property[] props = ent1.getProperties(new TagPath(tag));

        if (props == null || props.length == 0) {
            return NON + NON;
        }
        if (props.length != 1) {
            return err() + err();
        }

        Property prop = props[0]; // get only the first source
        if (prop == null || !(prop instanceof PropertyXRef)) {
            src += NON + NON;
        } else {
            Entity ent2 = ((PropertyXRef) prop).getTargetEntity();
            if (ent2 instanceof Source) {
                Source source = (Source) ent2;
                String sosa2 = sourceMap.get(source);
                if (sosa2 == null || sosa2.compareTo(sosa) != 0) {
                    sourceMap.put(source, sosa);
                    src += OUI;
                } else {
                    src += err();   // source already used for that individual
                }
                Property ptext = ent2.getProperty("TEXT");
                Property pobje = ent2.getPropertyByPath("SOUR:OBJE:FILE");
                src += ptext == null || ptext.toString().length() < 1 ? (pobje == null ? NON : err()) : (pobje == null ? fil() : OUI);
            } else {
                src += err() + NON;
            }
        }

        return src;
    }

    /**
     * Get family of an individual. Returned string is made of several elements:
     * - Event code of MARR event - family id - Other "MARR" type events (MARL,
     * MARC, DIV)
     */
    private String getFamilies(String sosa, Indi indi, boolean mandatory) {

        String line = "";
        Fam[] families = indi.getFamiliesWhereSpouse();

        if (families == null || families.length == 0) {
            return (mandatory ? err() + err() + err() + err() : "    ") + SPA + "    " + TAB + "    " + SPA + "    " + SPA + "    ";
        }

        Fam famFound = null;
        for (int i = 0; i < families.length; i++) {
            Fam family = families[i];
            // make sure that spouse is not the same as indi
            Indi spouse = family.getHusband();
            if (spouse == indi) {
                spouse = family.getWife();
            }
            // continue if spouse not valid (null, not an ancestor or a siblings)
            if (spouse != null && spouse.getProperty(SOSATAG) == null && (sosa.indexOf("-") == -1)) {
                continue;
            }
            famFound = family;
            break;
        }

        if (famFound != null) {
            line += getEvent(sosa, famFound, "FAM:MARR", mandatory);
            line += checkKidsOrder(famFound);
            line += TAB;
            line += famFound.getId();
            line += TAB;
            line += getEvent(sosa, famFound, "FAM:MARL", false);
            line += SPA;
            line += getEvent(sosa, famFound, "FAM:MARC", false);
            line += SPA;
            line += getEvent(sosa, famFound, "FAM:DIV", false);
            return line;
        }

        return NON + NON + NON + NON + TAB + NON + NON + NON + NON + TAB + "    " + SPA + "    " + SPA + "    ";
    }

    /**
     * Checks if place is valid and complete.
     */
    private String isValidAndComplete(Property prop) {

        if (prop == null || (!(prop instanceof PropertyDate)
                && !(prop instanceof PropertyPlace))) {
            return NON;
        }

        if (prop instanceof PropertyDate) {
            PropertyDate pDate = (PropertyDate) prop;
            if (pDate == null || !pDate.isValid() || pDate.isRange()) {
                return NON;
            }
            PropertyDate.Format pf = pDate.getFormat();
            if (pf != PropertyDate.DATE) {
                return NON;
            }
            PointInTime pit = pDate.getStart();
            if (!pit.isValid() || !pit.isComplete()) {
                return NON;
            }
            return OUI;
        }

        if (prop instanceof PropertyPlace) {
            String[] place = prop.toString().split("\\,", -1);
            if ((sizePlaces > 0) && (place.length != sizePlaces)) {
                return NON;
            }
            if (isEmpty(place)) {
                return NON;
            }
            return OUI;
        }

        return NON;
    }

    private boolean isEmpty(String[] tags) {
        if (tags == null) {
            return true;
        }
        for (int i = 0; i < tags.length; i++) {
            if (tags[i].trim().length() > 0) {
                return false;
            }
        }
        return true;
    }

    private String[] validatePlaceFormat(String placeFormat) {
        String[] tags = null;
        if (placeFormat.length() != 0) {
            tags = placeFormat.split("\\,", -1);
            for (int i = 0; i < tags.length; i++) {
                tags[i] = tags[i].trim();
            }
        }
        return tags;
    }

    /**
     * Check kids order in a family.
     */
    private String checkKidsOrder(Fam family) {

        String line = "";

        Indi[] kids = family.getChildren(false);
        if (kids == null || kids.length < 2) {
            return "";
        }
        PropertyDate pDate;
        PropertyDate pDatePrev = null;
        for (int i = 0; i < kids.length; i++) {
            pDate = kids[i].getBirthDate();
            if (pDate == null || !pDate.isValid()) {
                continue;
            }
            if ((pDatePrev != null) && (pDate.compareTo(pDatePrev) < 0)) {
                return seq();
            }
            pDatePrev = pDate;
        }

        return "";
    }

    /**
     * Counts nb of same str in a string.
     */
    private int numberOf(String str, String seq) {

        if (str == null || seq == null) {
            return 0;
        }
        int value = 0;
        int pos = 1;
        while (pos < str.length()) {
            pos = str.indexOf(seq, pos - 1) + 2;
            if (pos == 1) {
                break;
            }
            value++;
        }
        return value;
    }

    /**
     * Increments.
     */
    private String err() {
        cntAnomaly++;
        return ERR;
    }

    private String seq() {
        cntOutOfSeq++;
        return SEQ;
    }

    private String fil() {
        cntKnwnSrc++;
        return FIL;
    }

    /**
     * Check if directory is found in gedcom files.
     */
    private boolean checkDirectory(File directory, List<String> gedcomFiles) {

        boolean found = false;

        File[] files = directory.listFiles();
        if (files == null) {
            return false;
        }
        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory()) {
                found = found || checkDirectory(files[i], gedcomFiles);
            } else {
                String filename = files[i].getName();
                if (!gedcomFiles.contains(filename)) {
                    println(files[i].toString());
                    found = true;
                }
            }
        }
        return found;
    }
}