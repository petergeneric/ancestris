/*
 * Ancestris - http://www.ancestris.org
 * 
 * Copyright 2018 Ancestris
 * 
 * Author: Frédéric Lapeyre (frederic@ancestris.org).
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
package genj.common;

import ancestris.core.actions.AbstractAncestrisAction;
import genj.gedcom.Entity;
import genj.gedcom.Gedcom;
import genj.gedcom.MetaProperty;
import genj.gedcom.Property;
import genj.gedcom.PropertyComparator;
import genj.gedcom.TagPath;
import genj.util.Registry;
import genj.util.Resources;
import genj.util.WordBuffer;
import genj.util.swing.ImageIcon;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import javax.swing.AbstractListModel;
import javax.swing.ComboBoxModel;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JList;

/**
 *
 * @author frederic
 */
public class SelectEntityWidget extends javax.swing.JPanel {

    private final static Resources RESOURCES = Resources.get(SelectEntityWidget.class);
    private final static Registry REGISTRY = Registry.get(SelectEntityWidget.class);

    public final static String NEW = RESOURCES.getString("select.new");

    /**
     * type of entities to choose from
     */
    private String type = Gedcom.INDI;

    /**
     * entities to choose from
     */
    private Gedcom gedcom;
    private Entity[] list;
    private Object none;

    /**
     * widgets
     */

    /**
     * sorts
     */
    private TagPath sort;
    private List<TagPath> sorts;

    private final static String[] SORTS = {
        "INDI:NAME",
        "INDI",
        "INDI:BIRT:DATE",
        "INDI:DEAT:DATE",
        "FAM",
        "FAM:MARR:DATE",
        "FAM:HUSB:*:..:NAME",
        "FAM:WIFE:*:..:NAME",
        "OBJE",
        "OBJE:TITL",
        "OBJE:FILE:TITL",
        "NOTE",
        "NOTE:NOTE",
        "SOUR",
        "SOUR:TITL",
        "SOUR:ABBR",
        "SOUR:AUTH",
        "SOUR:REPO",
        "SUBM",
        "REPO",
        "REPO:NAME",
        "REPO:REFN",
        "REPO:RIN"
    };

    /**
     * Constructor
     *
     * @param gedcom
     * @param type Tag type eg Gedcom.INDI
     * @param none if non nul, string to display at first position. for instance
     * to set a "add new" entry
     */
    public SelectEntityWidget(Gedcom gedcom, String type, String none) {

        // Remember and lookup
        this.gedcom = gedcom;
        this.type = type;
        this.none = none;

        Collection<? extends Entity> entities = gedcom.getEntities(type);

        list = new Entity[entities.size()];
        int e = 0;
        for (Entity entity : entities) {
            if (!entity.getTag().equals(type)) {
                throw new IllegalArgumentException("Type of all entities has to be " + type);
            }
            list[e++] = entity;
        }

        // Assemble sorts
        sorts = new ArrayList<TagPath>(SORTS.length);
        for (int i = 0; i < SORTS.length; i++) {
            String path = SORTS[i];
            if (!path.startsWith(type)) {
                continue;
            }
            TagPath p = new TagPath(path);
            //FIXME: ce test ne fonctionne pas pour un tagpath du type "FAM:HUSB:*:..:NAME",
            //      if (!gedcom.getGrammar().isValid(p))
            //        continue;
            sorts.add(p);
            if (sort == null || path.equals(REGISTRY.get("select.sort." + type, ""))) {
                sort = p;
            }
        }

        initComponents();
        
        // Prepare sorting widget
        for (TagPath sort : sorts) {
            sortWidget.addItem(new SelectEntityWidget.Sort(sort));
        }

        // Prepare list widget    
        listWidget.setRenderer(new SelectEntityWidget.Renderer());

        // Explanation text
        explanationLabel.setText("<html>" + RESOURCES.getString((none == null ? "select.explanation.none" : "select.explanation")) + "</html>");

        

        // Init state
        sort(sort);
        if (none != null || list.length > 0) {
            listWidget.setSelectedIndex(0);
        }
        
        // done
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        explanationLabel = new javax.swing.JLabel();
        listWidget = new javax.swing.JComboBox();
        sortWidget = new genj.util.swing.PopupWidget();

        setPreferredSize(new java.awt.Dimension(500, 180));

        org.openide.awt.Mnemonics.setLocalizedText(explanationLabel, org.openide.util.NbBundle.getMessage(SelectEntityWidget.class, "SelectEntityWidget.explanationLabel.text")); // NOI18N

        listWidget.setMaximumRowCount(16);
        listWidget.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        org.openide.awt.Mnemonics.setLocalizedText(sortWidget, org.openide.util.NbBundle.getMessage(SelectEntityWidget.class, "SelectEntityWidget.sortWidget.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(sortWidget, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(listWidget, 0, 450, Short.MAX_VALUE))
                    .addComponent(explanationLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 0, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addComponent(explanationLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(sortWidget, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(listWidget))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(SelectEntityWidget.class, "SelectEntityWidget.AccessibleContext.accessibleName")); // NOI18N
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel explanationLabel;
    private javax.swing.JComboBox listWidget;
    private genj.util.swing.PopupWidget sortWidget;
    // End of variables declaration//GEN-END:variables


    /**
     * Sort by path
     */
    public void sort(TagPath path) {
        // remember
        sort = path;
        REGISTRY.put("select.sort." + type, path.toString());
        // Sort
        PropertyComparator comparator = new PropertyComparator(path);
        Arrays.sort(list, comparator);
        // reset our data
        Entity selection = getSelection();
        listWidget.setModel(new Model());
        sortWidget.setIcon(getPathImage(path));
        sortWidget.setToolTipText(getPathText(path));
        setSelection(selection);
    }

    private class Model extends AbstractListModel implements ComboBoxModel {

        private Object selection;

        public Object getSelectedItem() {
            return selection;
        }

        public void setSelectedItem(Object set) {
            selection = set;
        }

        public Object getElementAt(int index) {
            if (none != null) {
                return index == 0 ? none : list[index - 1];
            }
            return list[index];
        }

        public int getSize() {
            return list.length + (none != null ? 1 : 0);
        }

    }

    /**
     * Number of entities
     */
    public int getEntityCount() {
        return listWidget.getItemCount() - 1;
    }

    /**
     * The selected entity
     */
    public Entity getSelection() {
        // check selection
        Object item = listWidget.getSelectedItem();
        if (!(item instanceof Entity)) {
            return null;
        }
        // done
        return (Entity) item;
    }

    /**
     * The selected entity
     */
    public void setSelection(Entity set) {
        // fallback to none?
        if (set == null) {
            listWidget.setSelectedItem(none != null ? none : null);
        } else if (set.getTag().equals(type)) {
            listWidget.setSelectedItem(set);
        }
    }

    /**
     * Add a listener
     */
    public void addActionListener(ActionListener listener) {
        listWidget.addActionListener(listener);
    }

    /**
     * Remove a listener
     */
    public void removeActionListener(ActionListener listener) {
        listWidget.removeActionListener(listener);
    }

    private MetaProperty getMeta(TagPath tagPath) {
        MetaProperty meta;
        if (tagPath.length() > 1 && !tagPath.getLast().equals("TITL")) {
            meta = gedcom.getGrammar().getMeta(new TagPath(tagPath, 2), false);
        } else {
            meta = gedcom.getGrammar().getMeta(tagPath, false);
        }
        return meta;
    }

    private ImageIcon getPathImage(TagPath tagPath) {
        return getMeta(tagPath).getImage();
    }

    private String getPathText(TagPath tagPath) {
        String ID = RESOURCES.getString("select.sortID");
        return RESOURCES.getString("select.sort", tagPath.length() == 1 ? ID : getMeta(tagPath).getName());
    }

    
    
    
    
    
    
    /**
     * Entity Rendering
     */
    private class Renderer extends DefaultListCellRenderer {

        /**
         * @see
         * javax.swing.DefaultListCellRenderer#getListCellRendererComponent(javax.swing.JList,
         * java.lang.Object, int, boolean, boolean)
         */
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {

            // might be text of entity
            String txt;
            if (value instanceof Entity) {
                txt = getString((Entity) value);
            } else {
                txt = value != null ? value.toString() : "";
            }

            return super.getListCellRendererComponent(list, txt, index, isSelected, cellHasFocus);
        }

        /**
         * generate a string to show for entity&path
         */
        private String getString(Entity e) {

            if (sort == null) {
                return e.toString();
            }

            WordBuffer value = new WordBuffer(", ");

            // add sorting value first
            value.append(getString(e.getProperty(sort), "?"));

            // add all other sorts
            for (TagPath other : sorts) {
                if (!other.equals(sort) && other.getFirst().equals(sort.getFirst())) {
                    value.append(getString(e.getProperty(other), ""));
                }
            }

            // done
            return value.toString(); // + " / " + e.toString();
        }

        private String getString(Property p, String fallback) {
            if (p instanceof Entity) {
                return ((Entity) p).getId();
            } else {
                return p != null && p.isValid() ? p.getDisplayValue() : fallback;
            }
        }

    } //Renderer

    /**
     * Sort action
     */
    private class Sort extends AbstractAncestrisAction {

        /**
         * path
         */
        private TagPath tagPath;

        /**
         * Constructor
         */
        private Sort(TagPath path) {
            tagPath = path;
            setImage(getPathImage(path));
            setText(getPathText(path));
        }

        /**
         * @see genj.util.swing.AbstractAncestrisAction#execute()
         */
        public void actionPerformed(ActionEvent event) {
            sort(tagPath);
        }

    } //Sort

} //PickEntityWidget
